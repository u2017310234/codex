<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç±³ç²’å¤ªå£°ä¹åŠ©æ‰‹</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* === Base Styles === */
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #f3f4f6;
            /* Background image placeholder - uncomment and set your image path */
            /* background-image: url('path/to/your/background-image.jpg'); */
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }
        
        /* === Award Banner Styles === */
        .award-banner {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem 0;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 40;
        }
        
        .award-banner h1 {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        @media (max-width: 768px) {
            .award-banner h1 {
                font-size: 1.125rem;
                padding: 0 1rem;
            }
        }
        
        /* === QR Code Section === */
        .qr-code-section {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            margin-bottom: 1rem;
        }
        
        .qr-code-placeholder {
            width: 200px;
            height: 200px;
            margin: 1rem auto;
            border: 2px dashed #3B82F6;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f9fafb;
            color: #6b7280;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .qr-code-placeholder:hover {
            border-color: #2563EB;
            background-color: #eff6ff;
        }
        
        .qr-code-placeholder img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        /* === Button Styles (Consolidated) === */
        .control-button {
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: #e5e7eb;
            transition: all 0.2s ease-in-out;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            border: none;
        }
        
        .control-button:hover {
            background-color: #d1d5db;
        }
        
        .control-button.on {
            background-color: #FAF9F6 !important;
            color: black !important;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
        }
        
        .control-button.on svg {
            stroke: black;
        }
        
        /* === Range Button Styles === */
        #range_pane span {
            cursor: pointer;
            padding: 6px 12px;
            border: 1px solid #d1d5db;
            border-radius: 9999px;
            transition: all 0.2s ease-in-out;
        }
        
        #range_pane span:hover {
            background-color: #e5e7eb;
        }
        
        #range_pane span.on {
            background-color: #3B82F6;
            color: white;
            border-color: #2563EB;
        }
        
        /* === Canvas Styles === */
        #draw_pane {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #draw_pane canvas {
            max-width: 100%;
            height: auto !important;
            border-radius: 0.5rem;
            display: block;
        }
        
        /* === Transcript Container === */
        #transcriptContainer {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            padding: 15px;
            line-height: 1.6;
            background-color: #fafafa;
        }
        
        .transcript-item {
            transition: background-color 0.2s;
        }
        
        .transcript-item:hover {
            background-color: #f3f4f6;
        }
        
        .transcript-item.active {
            background-color: #dbeafe;
            border-left: 4px solid #3b82f6;
        }
        
        /* === Mobile Responsive Styles === */
        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
            }
            
            .md\:hidden .flex {
                flex-wrap: nowrap !important;
            }
            
            .md\:hidden button {
                white-space: nowrap;
                min-width: auto;
            }
            
            .qr-code-placeholder {
                width: 160px;
                height: 160px;
            }
        }
    </style>
</head>
<body class="text-gray-800">
    <!-- Award Banner Section -->
    <div class="award-banner">
        <h1>ğŸ† WAIC2025ä¸–ç•Œäººå·¥æ™ºèƒ½å¤§ä¼šå‚å±•é¡¹ç›® ğŸ†</h1>
    </div>
    
    <!-- æ‚¬æµ®è¯­è¨€ä¸‹æ‹‰èœå• -->
    <div class="fixed top-4 right-4 z-50" id="langDropdown">
        <button id="langToggle" class="flex items-center gap-2 px-3 py-2 bg-white hover:bg-gray-50 text-gray-700 text-sm rounded-lg shadow-lg border border-gray-200 transition-all duration-200">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
            <span id="currentLang">English</span>
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6,9 12,15 18,9"></polyline></svg>
        </button>
        <div id="langMenu" class="absolute top-full right-0 mt-2 w-32 bg-white rounded-lg shadow-xl border border-gray-200 py-1 hidden">
            <button class="lang-option w-full text-left px-3 py-2 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-600 transition-colors" data-lang="en">
                English
            </button>
            <button class="lang-option w-full text-left px-3 py-2 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-600 transition-colors" data-lang="zh">
                ä¸­æ–‡
            </button>
        </div>
    </div>
    
    <div class="container mx-auto p-4 max-w-5xl">
        <div id="draw_pane" class="bg-white p-2 rounded-xl shadow-2xl flex justify-center items-center overflow-x-auto mb-4">

        </div>
        
        <div class="bg-white p-4 rounded-xl shadow-lg mb-4">
            <!-- æ¡Œé¢ç«¯ï¼šå•è¡Œå¸ƒå±€ -->
            <div class="hidden md:flex items-center gap-4">
                <button id="mic_icon" title="Record Audio" class="control-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg>
                    <span>Record</span>
                </button>
                <button id="audio_pane" class="control-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 1 2 2h8a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2z"></path><polyline points="14,2 14,8 20,8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10,9 9,9 8,9"></polyline></svg>
                    <span>Upload</span>
                </button>
                <button id="playPauseBtn" class="p-3 rounded-lg bg-blue-500 hover:bg-blue-600 text-white transition-all duration-200">
                    <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>
                    <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="display:none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
                </button>
                <div class="flex-1 min-w-32">
                    <input type="range" id="progressSlider" min="0" max="100" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>
            
            <!-- æ‰‹æœºç«¯ï¼šä¸¤è¡Œç´§å‡‘å¸ƒå±€ -->
            <div class="md:hidden space-y-2">
                <!-- ç¬¬ä¸€è¡Œï¼šå½•éŸ³ã€ä¸Šä¼ ã€æ’­æ”¾ -->
                <div class="flex items-center justify-center gap-1 flex-nowrap">
                    <button id="mic_icon_mobile" title="Record Audio" class="control-button px-2 py-1.5 gap-0.5">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg>
                        <span>Record</span>
                    </button>
                    <button id="audio_pane_mobile" class="control-button px-2 py-1.5 gap-0.5">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 1 2 2h8a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2z"></path><polyline points="14,2 14,8 20,8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10,9 9,9 8,9"></polyline></svg>
                        <span>Upload</span>
                    </button>
                    <button id="playPauseBtn_mobile" class="p-1.5 rounded-lg bg-blue-500 hover:bg-blue-600 text-white transition-all duration-200 flex-shrink-0">
                        <svg id="playIcon_mobile" xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>
                        <svg id="pauseIcon_mobile" xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="currentColor" style="display:none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
                    </button>
                </div>
                <!-- ç¬¬äºŒè¡Œï¼šè¿›åº¦æ¡ -->
                <div class="flex items-center gap-2">
                    <div class="flex-1">
                        <input type="range" id="progressSlider_mobile" min="0" max="100" value="0" class="w-full h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>
            </div>
            
            <input type="file" id="audio_file" class="hidden" accept="audio/*">
            <audio id="myAudio" controls class="hidden"></audio>
        </div>
        
        <!-- Transcript Container -->
        <div id="transcriptContainer">
        </div>
        
        <!-- QR Code Section -->
        <div class="qr-code-section">
            <h3 class="text-lg font-semibold text-gray-800 mb-2">æ‰«ç åˆ†äº« / ç§»åŠ¨ç«¯é•¿æŒ‰ä¿å­˜</h3>
            <div class="qr-code-placeholder" id="qrCodePlaceholder">
                <span>ğŸ“± äºŒç»´ç å ä½åŒºåŸŸ<br>ç‚¹å‡»ä¸Šä¼ äºŒç»´ç å›¾ç‰‡</span>
                <!-- Placeholder for QR code image - can be replaced with actual QR code -->
            </div>
            <p class="text-sm text-gray-600 mt-2">ç”µè„‘ç«¯å¯æ‰«ç è®¿é—®ï¼Œç§»åŠ¨ç«¯å¯é•¿æŒ‰ä¿å­˜äºŒç»´ç </p>
        </div>

    </div>


    <!-- JavaScript Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/addons/p5.sound.min.js"></script>

    <!-- Script 1: Dependencies, Mocks, and Helper Functions -->
    <script>
        // This script provides all the necessary data structures and helper functions
        // that were not included in the original code file.

        // Mock Locale object for text strings

        const transcriptContainer = document.getElementById('transcriptContainer');
        let currentTranscript = [];
        let token= null;
        const API_BASE = '/api';
        
        // ä¿ç•™ä½œä¸ºåå¤‡æ•°æ®
        const mockTranscript = [
            { start: 0.0, end: 0.0, text: 'è§£æå¤±è´¥å“¦ï¼Œè¯·é‡è¯•ä¸€æ¬¡å§ï¼' },
        ];
        document.addEventListener('DOMContentLoaded', async () => {
        // ä»URLä¸­è§£æå‡ºtoken
        const urlParams = new URLSearchParams(window.location.search);
        token = urlParams.get('token');

        if (!token) {
            statusP.textContent = 'é”™è¯¯ï¼šæ— æ•ˆçš„é“¾æ¥ï¼Œç¼ºå°‘ä»¤ç‰Œã€‚';
            statusP.style.color = 'red';
            return;
        }
        
        // Initialize QR code placeholder functionality
        initQRCodePlaceholder();
    });
    
        // QR Code placeholder functionality
        function initQRCodePlaceholder() {
            const qrPlaceholder = document.getElementById('qrCodePlaceholder');
            if (!qrPlaceholder) return;
            
            // Create hidden file input for QR code upload
            const qrInput = document.createElement('input');
            qrInput.type = 'file';
            qrInput.accept = 'image/*';
            qrInput.style.display = 'none';
            qrInput.id = 'qrCodeInput';
            document.body.appendChild(qrInput);
            
            // Handle click on placeholder
            qrPlaceholder.addEventListener('click', () => {
                qrInput.click();
            });
            
            // Handle file selection
            qrInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        qrPlaceholder.innerHTML = `<img src="${event.target.result}" alt="QR Code" style="max-width: 100%; max-height: 100%;">`;
                    };
                    reader.readAsDataURL(file);
                }
            });
        }
    
        function formatTime(s) {
          if(isNaN(s) || s < 0) return "0:00"; 
          const minutes = Math.floor(s / 60);
          const seconds = Math.floor(s % 60).toString().padStart(2, '0');
          return `${minutes}:${seconds}`;
          }
        function renderTranscript(transcriptData = currentTranscript, disabled = false) {
            transcriptContainer.innerHTML = '';
            if (transcriptData.length === 0) {
                const message = Locale.currentLang === 'zh' ? 'ç‚¹å‡»æŒ‰é’®ã€å½•åˆ¶ã€‘æˆ–ã€ä¸Šä¼ ã€‘éŸ³é¢‘ï¼Œå¾—åˆ°åˆ†æç»“æœï¼\næ¬¡æ•°ä¸º0æ—¶æ— æ³•è¿›è¡Œåˆ†æï¼Œéœ€è¦æ‰¾ä½ çš„è€å¸ˆå¸®å¿™å“¦ï¼\nå½“å‰å‰©ä½™åˆ†ææ¬¡æ•°ï¼š' : 'Upload or record audio to see analysis results';
                transcriptContainer.innerHTML = `<div class="text-gray-500 text-center p-4">${message}</div>`;
                return;
            }
            transcriptData.forEach(item => {
                const div = document.createElement('div');
                div.className = `transcript-item p-3 border-b border-gray-100 ${disabled ? 'opacity-50' : 'cursor-pointer hover:bg-gray-50'}`;
                div.innerHTML = `<span class="font-mono text-sm text-blue-700 mr-4">[${formatTime(item.start)} - ${formatTime(item.end)}]</span><span class="text-gray-700">${item.text}</span>`;
                if (!disabled) {
                    div.addEventListener('click', () => {
                        if (data.control.audio.src) {
                            data.control.audio.currentTime = item.start;
                            data.control.playSegment(item.start, item.end);
                        }
                    });
                }
                div.dataset.start = item.start;
                div.dataset.end = item.end;
                transcriptContainer.appendChild(div);
            });
        }
        function updateTranscriptHighlight(time) {
            document.querySelectorAll('.transcript-item').forEach(item => {
                const start = parseFloat(item.dataset.start);
                const end = parseFloat(item.dataset.end);
                item.classList.toggle('active', time >= start && time < end);
            });
        }
        
        // APIè°ƒç”¨å‡½æ•°
        async function uploadAudioFile(file) {
            const formData = new FormData();
            formData.append('audio', file);
            
            try {
                const response = await fetch(`${API_BASE}/upload`, {
                    method: 'POST',
                    headers: {
                'Authorization': 'Bearer default-dev-key-12345',
                'token': token
            },
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error!! status: ${response.status}`);
                }
                
                const result = await response.json();
                return result;
            } catch (error) {
                console.error('Upload error:', error);
                return { error: error.message };
            }
        }
        
        async function analyzeTranscript(audioId) {
            try {
                const response = await fetch(`${API_BASE}/analyze_transcript`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer default-dev-key-12345',
                        'token': token
                    },
                    body: JSON.stringify({ file_id: audioId })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                return result;
            } catch (error) {
                console.error('Analysis error:', error);
                return { error: error.message };
            }
        }


        const Locale = {
            currentLang: 'zh',
            data: {
                'en': {
                    'no_support': 'Sorry, your browser does not support the Web Audio API. Please try a modern browser like Chrome or Firefox.',
                    'no_mic': 'Could not access the microphone. Please grant permission and refresh the page.',
                    'paused': 'Paused',
                    'overtone': 'Overtone',
                    'head_voice': 'Head Voice',
                    'super_fake_voice': 'Falsetto',
                    'pure_fake_voice': 'Light Falsetto',
                    'fake_voice': 'Breathy',
                    'half_fake_voice': 'Light Mix',
                    'mix_voice': 'Mixed Voice',
                    'modal_voice': 'Chest Voice',
                    'pure_modal_voice': 'Strong Chest',
                    'man': 'Male',
                    'woman': 'Female',
                    'record': 'Record',
                    'upload': 'Upload',
                    'lang_toggle': 'ä¸­æ–‡'
                },
                'zh': {
                    'no_support': 'æŠ±æ­‰ï¼Œæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Audio APIã€‚è¯·ä½¿ç”¨ç°ä»£æµè§ˆå™¨å¦‚ Chrome æˆ– Firefoxã€‚',
                    'no_mic': 'æ— æ³•è®¿é—®éº¦å…‹é£ã€‚è¯·æˆäºˆæƒé™å¹¶åˆ·æ–°é¡µé¢ã€‚',
                    'paused': 'å·²æš‚åœ',
                    'overtone': 'æ³›éŸ³',
                    'head_voice': 'å¤´å£°',
                    'super_fake_voice': 'å‡å£°',
                    'pure_fake_voice': 'è½»å‡å£°',
                    'fake_voice': 'æ°”å£°',
                    'half_fake_voice': 'è½»æ··å£°',
                    'mix_voice': 'æ··å£°',
                    'modal_voice': 'èƒ¸å£°',
                    'pure_modal_voice': 'å¼ºèƒ¸å£°',
                    'man': 'ç”·æ€§',
                    'woman': 'å¥³æ€§',
                    'record': 'å½•éŸ³',
                    'upload': 'ä¸Šä¼ ',
                    'lang_toggle': 'English'
                }
            },
            get: function(key) {
                return this.data[this.currentLang][key] || key;
            },
            setLang: function(lang) {
                this.currentLang = lang;
                this.updateUI();
            },
            updateUI: function() {
                // æ›´æ–°æŒ‰é’®æ–‡å­—
                document.querySelector('#mic_icon span').textContent = this.get('record');
                document.querySelector('#audio_pane span').textContent = this.get('upload');
                document.querySelector('#mic_icon_mobile span').textContent = this.get('record');
                document.querySelector('#audio_pane_mobile span').textContent = this.get('upload');
                // æ›´æ–°ä¸‹æ‹‰èœå•å½“å‰è¯­è¨€æ˜¾ç¤º
                document.querySelector('#currentLang').textContent = this.currentLang === 'en' ? 'English' : 'ä¸­æ–‡';
                // æ›´æ–°è½¬å½•å®¹å™¨æ–‡å­—
                if (currentTranscript.length === 0) {
                    renderTranscript();
                }
            }
        };

        // Mock EqualLoudness class as it was missing
        function EqualLoud() {
            this.adjust = function(index, value) {
                // This function is intended to adjust frequencies based on human hearing (equal-loudness contour).
                // For this implementation, we'll return the value unmodified.
                return value;
            }
        }

        // Generate Pitch Data for a standard 88-key piano (A0 to C8)
        const PITCH_DATA = [];
        const noteNames = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
        for (let i = 0; i < 88; i++) {
            const keyNum = i + 1; // MIDI key number offset for piano
            const octave = Math.floor((i + 9) / 12);
            const noteIndex = i % 12;
            const noteName = noteNames[noteIndex];
            const freq = 440.0 * Math.pow(2, (keyNum - 49) / 12.0);
            PITCH_DATA.push({
                name: noteName + octave,
                inter: noteName + octave, // Used by the original script
                value: freq,
                is_white: !noteName.includes("#"),
                sound: null // This will be handled by a p5.Oscillator, not file loading
            });
        }

        // Helper function to get the closest pitch for a given frequency
        function getPitch(freq) {
            if (freq <= 0) return null;
            let closestPitch = null;
            let minDiff = Infinity;

            for (const pitch of PITCH_DATA) {
                const diff = Math.abs(pitch.value - freq);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestPitch = { ...pitch }; // Return a copy
                }
            }
            return closestPitch;
        }

        // Pre-defined vocal range data
        const RANGE_DATA = {
            'soprano': { name: 'Soprano', low: getPitch(261.63), high: getPitch(1046.50) },
            'mezzo': { name: 'Mezzo-Soprano', low: getPitch(220.00), high: getPitch(880.00) },
            'alto': { name: 'Alto', low: getPitch(174.61), high: getPitch(698.46) },
            'tenor': { name: 'Tenor', low: getPitch(130.81), high: getPitch(523.25) },
            'baritone': { name: 'Baritone', low: getPitch(98.00), high: getPitch(392.00) },
            'bass': { name: 'Bass', low: getPitch(82.41), high: getPitch(329.63) },
            'man_high': { name: 'High Male', low: getPitch(130.81), high: getPitch(523.25) },
            'woman_high': { name: 'High Female', low: getPitch(261.63), high: getPitch(1046.50) }
        };

        function getRange(name) {
            return RANGE_DATA[name];
        }

        // Dummy function for a call that was not defined in the original code
        function setupInput() {
            // This is often used to resume the AudioContext on a user gesture, which is required by modern browsers.
            if (getAudioContext() && getAudioContext().state !== 'running') {
                getAudioContext().resume();
                console.log('AudioContext resumed.');
            }
        }
    </script>

    <!-- Script 2: The User's Original Application Logic (with minor fixes) -->
    <script>
    'use strict';

    // This is the original code provided, with modifications to use the mock data
    // and replace external dependencies (like sound files) with internal solutions.

    function preload() {
      if (window.location.protocol != "https:" && window.location.protocol != 'file:')
        window.location.href = "https:" + window.location.href.substring(window.location.protocol.length);
    }

    function setup() {
      if (!window.AudioContext && !window.webkitAudioContext) {
        window.alert(Locale.get('no_support'));
        noLoop(); // Stop p5.js from running
        return;
      }
      data.init();
      data.control = new Control();
      
      data.equal_loud = new EqualLoud();
      frameRate(data.fps);
      var cnv = createCanvas(data.width + data.padding_right, 500);
      cnv.parent('draw_pane');
      cnv.mouseClicked(data.control.onClick);
      data.fft = new p5.FFT(data.smooth, data.fft_size);
      if (!data.no_mic) {
        data.mic_fft = new p5.FFT(data.smooth, data.fft_size);
      }
      renderTranscript();

    var x1 = 2;
    var x2 = data.width;
    var y1 = 1;
    var y2 = 0;

   if (data.show_piano) {
        y2 = y1 + Math.ceil(data.width / 9);
        piano.init(x1, x2, y1, y2);
        y1 = y2 + 30;
    }

    // å®šä¹‰å‚ç›´ç»„ä»¶çš„é«˜åº¦
    let verticalComponentHeight = 450;
    y2 = y1 + verticalComponentHeight;

    // --- æ–°çš„æ°´å¹³ä¸‰æ å¸ƒå±€ ---
    let totalWidth = data.width;
    let vspecWidth = totalWidth * 0.8;
    let ladderWidth = 80; // éŸ³é«˜æ ‡å°ºçš„å®½åº¦
    let specWidth = totalWidth - vspecWidth - ladderWidth;

    // 1. åˆå§‹åŒ– vspec (70% å®½åº¦)
    if (data.show_vspec) {
        vspec.init(x1, x1 + vspecWidth, y1, y2);
    }

    // 2. åˆå§‹åŒ–æ–°çš„éŸ³é«˜æ ‡å°º (å›ºå®šå®½åº¦)
    pitchLadder.init(x1 + vspecWidth, x1 + vspecWidth + ladderWidth, y1, y2);

    // 3. åˆå§‹åŒ– spec (å‰©ä½™å®½åº¦)
    if (data.show_spec) {
        spec.init(x1 + vspecWidth + ladderWidth, x2, y1, y2);
    }
    
    y1 = y2 + 10; // ä¸ºåº•éƒ¨å¯èƒ½å­˜åœ¨çš„å…¶ä»–ç»„ä»¶æ›´æ–°yåæ ‡


      // ======================

      var audioCtx = getAudioContext();
      // The audio element source is connected when a file is loaded.
      // data.fft.setInput(source);
      // source.connect(audioCtx.destination);
      
      if (!data.no_mic) {
        data.mic = new p5.AudioIn(err => {
            console.error(err);
            data.no_mic = true;
            data.use_mic = false;
            data.control.showNoMicDialog();
        });
        data.mic_fft.setInput(data.mic);
        // data.control.toggleMic(data.use_mic); // ä¸è¦è‡ªåŠ¨å¼€å§‹å½•éŸ³
      } else {
        data.use_mic = false;
        data.control.showNoMicDialog();
      }

      if (!data.input_pane) {
        jQuery('#input_pane').hide();
      }
      bindUploadEvents();
    }
      //
      function bindUploadEvents() {
        const uploadBtns = [
          document.getElementById("audio_pane"),
          document.getElementById("audio_pane_mobile")
        ];
        const uploadInput = document.getElementById("audio_file"); // å…¬å…±æ–‡ä»¶ input

        const uploadBtn = uploadBtns.find(btn => btn !== null);
        if (uploadBtn) {
            uploadBtn.addEventListener("click", async () => {
                if (getAudioContext().state === "suspended") {
                    await getAudioContext().resume();
                }
                //newUploadInput.click(); // å¼¹å‡ºæ–‡ä»¶é€‰æ‹©
            });
        }
      }

    function draw() {
      background(255);
      data.pitch = null;

      data.mousemove_pitch = piano.mouseToPitch();
      spec.handleMouseMove();
      vspec.handleMouseMove();
      if (!data.mousemove_pitch && data.backup_pitch) {
        data.mousemove_pitch = data.backup_pitch;
      }

      data.control.onDraw();
      top_model.getValue();
      top_model.guessPitch();
      data.control.drawText();
      if (data.show_spec) {
        spec.onDraw();
        
      }
      if (data.show_vspec) {
        vspec.onDraw();
      }
      

      if (data.show_piano) {
        piano.onDraw();
      }

    }
    
    async function waitForFileToBeActive(fileId, maxAttempts = 10, delayMs = 1000) {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const response = await fetch(`/api/file-status?id=${fileId}`);
        const result = await response.json();

        if (result.status === 'ACTIVE') {
            return true;
        }

        await new Promise(resolve => setTimeout(resolve, delayMs));
    }

    throw new Error('æ–‡ä»¶æœªåœ¨é¢„æœŸæ—¶é—´å†…å˜ä¸º ACTIVE');
}
    function Control() {
      var self = this;
      this.mic_icon = jQuery("#mic_icon");
      this.audio_pane = jQuery("#audio_pane");
      this.audio = jQuery('#myAudio')[0];
      this.mic_on = false;


      let mediaRecorder = null;
      let recordedChunks = [];

      this.pitch_name = jQuery("#pitch_name");
      this.pitch_pure = jQuery("#pitch_pure");

      jQuery('input#audio_file').on('change', async function(e) {
        const file = jQuery('#audio_file')[0].files[0];
        if (!file) return;
        
        // ç«‹å³è®¾ç½®éŸ³é¢‘æºå’Œå£°è°±å›¾
        var path = URL.createObjectURL(file);
        self.audio.src = path;
        self.audio.load();
        
        // Connect audio element to FFT
        var audioCtx = getAudioContext();
        if (self.audioSource) {
            self.audioSource.disconnect();
        }
        self.audioSource = audioCtx.createMediaElementSource(self.audio);
        data.fft.setInput(self.audioSource);
        self.audioSource.connect(audioCtx.destination);
        
        self.toggleAudio(true);
        
        // å¼‚æ­¥å¤„ç†æ–‡å­—åˆ†æ
        const loadingMsg = Locale.currentLang === 'zh' ? 'æ­£åœ¨åˆ†æéŸ³é¢‘...' : 'Analyzing audio...';
        transcriptContainer.innerHTML = `<div class="text-center p-4"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto"></div><p class="mt-2 text-gray-600">${loadingMsg}</p></div>`;
        
        const uploadResult = await uploadAudioFile(file);
        
        if (uploadResult.error) {
            const errorMsg = Locale.currentLang === 'zh' ? 'åˆ†æå¤±è´¥' : 'Analysis failed';
            transcriptContainer.innerHTML = `<div class="text-red-500 text-center p-4">${errorMsg}: ${uploadResult.error}</div>`;
            return;
        }
        
        const analysisResult = await analyzeTranscript(uploadResult.file_id);
        
        if (
            analysisResult.error ||
            !analysisResult.data ||
            !Array.isArray(analysisResult.data.segments)
        ) {
            console.warn("åˆ†æå¤±è´¥æˆ–ç»“æœä¸ºç©ºï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ã€‚", analysisResult?.error || analysisResult);

            currentTranscript = mockTranscript;
        } else {
            currentTranscript = analysisResult.data.segments;
        }
        
        //currentTranscript = analysisResult.data.segments;
        renderTranscript(currentTranscript);
      });

      this.togglePlay = function() {
        data.lock_spec = !data.lock_spec;
        if (data.use_mic) {
          this.toggleMic(!data.lock_spec);
        } else {
          this.toggleAudio(!data.lock_spec);
        }
      };

      this.toggleMic = function(enable) {
        if (data.no_mic) {
            data.use_mic = false;
            return;
        }

        this.mic_on = enable;

        if (enable) {
            data.use_mic = true;
            data.mic.start();
            this.mic_icon.addClass('on');
            this.mic_icon_mobile.addClass('on');
            this.toggleAudio(false);
            data.lock_spec = false;

            navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
                mediaRecorder = new MediaRecorder(stream);
                recordedChunks = [];

                mediaRecorder.ondataavailable = function (e) {
                    if (e.data.size > 0) {
                        recordedChunks.push(e.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    const blob = new Blob(recordedChunks, { type: 'audio/ogg' });

                    // ğŸ‘‡ æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
                    const loadingMsg = Locale.currentLang === 'zh' ? 'æ­£åœ¨åˆ†æå½•éŸ³ï¼Œè¯·ç¨å€™...' : 'Analyzing recording...';
                    transcriptContainer.innerHTML = `<div class="text-center p-4"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto"></div><p class="mt-2 text-gray-600">${loadingMsg}</p></div>`;

                    // ğŸ‘‡ ä¸Šä¼ å½•éŸ³
                    const file = new File([blob], 'recording.ogg', { type: 'audio/ogg' });
                    this.uploadResult = await uploadAudioFile(file);

                    if (this.uploadResult.error) {
                        const errorMsg = Locale.currentLang === 'zh' ? 'å½•éŸ³ä¸Šä¼ å¤±è´¥' : 'Upload failed';
                        transcriptContainer.innerHTML = `<div class="text-red-500 text-center p-4">${errorMsg}: ${uploadResult.error}</div>`;
                        currentTranscript = mockTranscript;
                        renderTranscript(currentTranscript);
                        return;
                    }

                     
                          
                    try {
          
                        await waitForFileToBeActive(this.uploadResult.file_id);
                        console.log(this.uploadResult.file_id);
         
                        const analysisResult = await analyzeTranscript(this.uploadResult.file_id);
                        currentTranscript = analysisResult?.data?.segments || mockTranscript;
                        renderTranscript(currentTranscript);
                    } catch (err) {
                        console.error('å½•éŸ³åˆ†æå¤±è´¥ï¼š', err);
                        const errorMsg = Locale.currentLang === 'zh' ? 'å½•éŸ³åˆ†æå¤±è´¥ï¼Œè¯·ç¨åå†è¯•' : 'Analysis failed, please try again later';
                        transcriptContainer.innerHTML = `<div class="text-red-500 text-center p-4">${errorMsg}</div>`;
                        currentTranscript = mockTranscript;
                        renderTranscript(currentTranscript);
                    }
                };

                mediaRecorder.start();
            }).catch(function (err) {
                console.error('æ— æ³•è®¿é—®éº¦å…‹é£', err);
                data.use_mic = false;
            });

        } else {
            data.mic.stop();
            this.mic_icon.removeClass('on');
            this.mic_icon_mobile.removeClass('on');

            // ğŸ‘‡ åœæ­¢å¹¶è§¦å‘ä¸Šä¼ 
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
            }
        }
    };     
      this.analyzeRecording = function () {
          const loadingMsg = Locale.currentLang === 'zh'
              ? 'æ­£åœ¨åˆ†æå½•éŸ³... å¤§æ¦‚éœ€è¦45ç§’'
              : 'Analyzing recording... Please wait for about 45s';

          transcriptContainer.innerHTML = `
              <div class="text-center p-4">
                  <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto"></div>
                  <p class="mt-2 text-gray-600">${loadingMsg}</p>
              </div>`;

          setTimeout(async () => {
              if (!this.uploadResult || !this.uploadResult.file_id) {
                  console.warn('æ²¡æœ‰æœ‰æ•ˆçš„ä¸Šä¼ ç»“æœ');
                  transcriptContainer.innerHTML = `<div class="text-red-500 text-center p-4">æ‰¾ä¸åˆ°å½•éŸ³æ–‡ä»¶ï¼Œè¯·é‡æ–°å½•åˆ¶</div>`;
                  return;
              }

              try {
                  await waitForFileToBeActive(this.uploadResult.file_id);
                  const analysisResult = await analyzeTranscript(this.uploadResult.file_id);

                  if (
                      analysisResult.error ||
                      !analysisResult.data ||
                      !Array.isArray(analysisResult.data.segments)
                  ) {
                      console.warn("åˆ†æå¤±è´¥æˆ–æ— ç»“æœï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ã€‚", analysisResult?.error || analysisResult);
                      currentTranscript = mockTranscript;
                  } else {
                      currentTranscript = analysisResult.data.segments;
                  }

                  renderTranscript(currentTranscript);
              } catch (err) {
                  console.error("åˆ†æå¤±è´¥ï¼š", err);
                  transcriptContainer.innerHTML = `<div class="text-red-500 text-center p-4">åˆ†æå¤±è´¥ï¼Œè¯·ç¨åå†è¯•</div>`;
                  currentTranscript = mockTranscript;
                  renderTranscript(currentTranscript);
              }
          }, 1000);
      };
      this.toggleAudio = function(enable) {
        if (enable && !this.audio.src) return;
        if (enable) {
          data.use_mic = false;
          this.audio.play();
          this.toggleMic(false);
          this.audio_pane.addClass('on');
          this.audio_pane_mobile.addClass('on');
          data.lock_spec = false;
          this.updatePlayButton(true);
        } else {
          this.audio.pause();
          this.audio_pane.removeClass('on');
          this.audio_pane_mobile.removeClass('on');
          this.updatePlayButton(false);
        }
      };
      
      this.playSegment = function(startTime, endTime) {
        this.segmentEndTime = endTime;
        this.audio.currentTime = startTime;
        this.toggleAudio(true);
      };
      
      // æ¡Œé¢ç«¯æ§ä»¶
      this.playPauseBtn = jQuery('#playPauseBtn');
      this.playIcon = jQuery('#playIcon');
      this.pauseIcon = jQuery('#pauseIcon');
      this.progressSlider = jQuery('#progressSlider');

      
      // ç§»åŠ¨ç«¯æ§ä»¶
      this.mic_icon_mobile = jQuery('#mic_icon_mobile');
      this.audio_pane_mobile = jQuery('#audio_pane_mobile');
      this.playPauseBtn_mobile = jQuery('#playPauseBtn_mobile');
      this.playIcon_mobile = jQuery('#playIcon_mobile');
      this.pauseIcon_mobile = jQuery('#pauseIcon_mobile');
      this.progressSlider_mobile = jQuery('#progressSlider_mobile');

      
      // æ’­æ”¾æŒ‰é’®äº‹ä»¶ï¼ˆæ¡Œé¢ç«¯å’Œç§»åŠ¨ç«¯ï¼‰
      const playPauseHandler = () => {
        if (this.audio.src) {
          if (this.audio.paused) {
            this.toggleAudio(true);
          } else {
            this.toggleAudio(false);
          }
        }
      };
      this.playPauseBtn.click(playPauseHandler);
      this.playPauseBtn_mobile.click(playPauseHandler);
      
      // è¿›åº¦æ¡äº‹ä»¶
      const progressHandler = (slider) => {
        if (this.audio.src) {
          const time = (slider.val() / 100) * this.audio.duration;
          this.audio.currentTime = time;
        }
      };
      this.progressSlider.on('input', () => progressHandler(this.progressSlider));
      this.progressSlider_mobile.on('input', () => progressHandler(this.progressSlider_mobile));
      

      
      // ç§»åŠ¨ç«¯å½•éŸ³å’Œä¸Šä¼ æŒ‰é’®
      this.mic_icon_mobile.click(() => {
        setupInput();
        self.toggleMic(!self.mic_on);
        if (self.mic_on) {
          data.lock_spec = false;
          self.startRealtimeAnalysis();
        } else {
          self.stopRealtimeAnalysis();
        }
      });
      
      this.audio_pane_mobile.click(() => {
        jQuery('#audio_file').click();
      });
      
      // è¯­è¨€ä¸‹æ‹‰èœå•
      const langToggle = jQuery('#langToggle');
      const langMenu = jQuery('#langMenu');
      const currentLangSpan = jQuery('#currentLang');
      
      langToggle.click((e) => {
        e.stopPropagation();
        langMenu.toggleClass('hidden');
      });
      
      jQuery('.lang-option').click(function() {
        const selectedLang = jQuery(this).data('lang');
        Locale.setLang(selectedLang);
        langMenu.addClass('hidden');
      });
      
      // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
      jQuery(document).click(() => {
        langMenu.addClass('hidden');
      });
      
      // ç›‘å¬éŸ³é¢‘æ’­æ”¾è¿›åº¦
      this.audio.addEventListener('timeupdate', () => {
        updateTranscriptHighlight(this.audio.currentTime);
        
        // æ›´æ–°è¿›åº¦æ¡ï¼ˆæ¡Œé¢ç«¯å’Œç§»åŠ¨ç«¯ï¼‰
        if (this.audio.duration) {
          const progress = (this.audio.currentTime / this.audio.duration) * 100;
          this.progressSlider.val(progress);
          this.progressSlider_mobile.val(progress);
        }
        
        // ç‰‡æ®µæ’­æ”¾æ§åˆ¶
        if (this.segmentEndTime && this.audio.currentTime >= this.segmentEndTime) {
          this.toggleAudio(false);
          this.segmentEndTime = null;
        }
      });
      
      // æ›´æ–°æ’­æ”¾æŒ‰é’®å›¾æ ‡ï¼ˆæ¡Œé¢ç«¯å’Œç§»åŠ¨ç«¯ï¼‰
      this.updatePlayButton = function(isPlaying) {
        if (isPlaying) {
          this.playIcon.hide();
          this.pauseIcon.show();
          this.playIcon_mobile.hide();
          this.pauseIcon_mobile.show();
        } else {
          this.playIcon.show();
          this.pauseIcon.hide();
          this.playIcon_mobile.show();
          this.pauseIcon_mobile.hide();
        }
      };

      this.onClick = function() {
        if (data.show_spec && spec.mouseInRect()) {
          self.togglePlay();
        } else if (data.show_vspec && vspec.mouseInRect()) {
          self.togglePlay();
        } else if (data.show_piano && piano.mouseInRect()) {
          piano.playPitch(piano.mouseToPitch());
        }
      };

      this.onDraw = function() {
        // This logic seems to force audio off if mic is on, which is good.
        // if (data.use_mic && !this.audio.paused) {
        //   this.toggleAudio(false); 
        // }
      };

      this.drawText = function() {
        // Draw text.
        {

          var str = '';
          if (data.pitch) {
            str += data.pitch[data.pitch_name];
          }
          this.pitch_name.text(str || '-');
          str = '';
          if (data.max_top) {
            str += data.max_top.getPureName();
          }
          this.pitch_pure.text(str || '-');
        }
      };

      this.showNoMicDialog = function() {
        // Use a less intrusive notification if possible
        console.warn(Locale.get('no_mic'));
        // window.alert(Locale.get('no_mic'));
      }

      this.mic_icon.click(function() {
        setupInput();
        self.toggleMic(!self.mic_on);
        if (self.mic_on) {
          data.lock_spec = false;
          // å¼€å§‹å®æ—¶åˆ†æ
          self.startRealtimeAnalysis();
        } else {
          self.stopRealtimeAnalysis();
        }
      });
      
      // å®æ—¶åˆ†æç›¸å…³æ–¹æ³•
      this.startRealtimeAnalysis = function() {
        if (this.analysisInterval) return;
        
        this.analysisInterval = setInterval(async () => {
          if (!data.use_mic || !data.mic) return;
          
          // è¿™é‡Œå¯ä»¥æ·»åŠ å®æ—¶éŸ³é¢‘æ•°æ®é‡‡é›†å’Œåˆ†æ
          // ç”±äºp5.jsçš„é™åˆ¶ï¼Œè¿™é‡Œä»…åšç¤ºä¾‹
          console.log('Real-time analysis running...');
        }, 1000);
      };
      
      this.stopRealtimeAnalysis = function() {
        if (this.analysisInterval) {
          clearInterval(this.analysisInterval);
          this.analysisInterval = null;
        }
      };
      
      this.audio_pane.click(function() {
        jQuery('#audio_file').click();
      });

      var range_pane = jQuery('#range_pane');
      this.ranges = [];
      for (var range_name in RANGE_DATA) {
        range_pane.append('<span id="' + range_name + '">' + getRange(range_name).name + '</span>');
        this.ranges.push(jQuery('#' + range_name));
      }
      for (var i = 0; i < this.ranges.length; i++) {
        var range_span = this.ranges[i];
        range_span.click(function() {
          var name = this.id;
          data.range_name = name;
          self.updateRangePane();
        });
      }

      this.updateRangePane = function() {
        for (var i = 0; i < self.ranges.length; i++) {
          var range_span = self.ranges[i];
          if (range_span.attr('id') == data.range_name) {
            range_span.addClass('on');
          } else {
            range_span.removeClass('on');
          }
        }
      };

      this.updateRangePane();
    }

    function Top(index) {
      this.total_eng = -1;
      this.left_top = null;
      this.left_low_eng = 0;
      this.overtone_count = 1;
      this.valid = true;
      this.pure = 0;



      this.init(index);
    }


    Top.prototype.init = function(index) {
      this.right_index = index;
      this.eng = data.spectrum[index];
      this.ori_eng = data.ori_spectrum[index];
      this.left_index = this.extend(index, -1);
      this.right_index = this.extend(index, 1);
      this.index = (this.left_index + this.right_index) / 2;
      if (this.eng < data.min_eng) this.valid = false;
    };

    Top.prototype.extend = function(index, delta) {
      while (true) {
        index += delta;
        if (index < 0 || index > data.x_max) return index - delta;
        var eng = data.spectrum[index];
        if (eng > this.eng) {
          return index - delta;
        } else if (eng + data.top_eng_range < this.eng) {
          return index - delta;
        }
      }
    };

    Top.prototype.calculateParent = function(i) {
      if (i == 1) return true;
      var parent_index = this.index * i;
      if (parent_index > data.x_max) {
        return false;
      }
      var parent = data.getTop(this.left_index * i, Math.ceil(this.right_index * i));

      if (!parent || parent.eng < data.accept_eng) {
        return false;
      }
      this.parents[i] = parent;
      this.overtone_count++;
      if (i < 4 || parent == data.highest_top) {
        this.left_index = Math.max(this.left_index, (parent.left_index - 1) / i);
        this.right_index = Math.min(this.right_index, (parent.right_index + 1) / i);
      }
      this.max_oevrtone_ori_eng = Math.max(this.max_oevrtone_ori_eng, parent.ori_eng);
      this.addTotalEng(parent.eng);
      return true;
    };

    Top.prototype.calculate = function(highest_index) {
      if (this.total_eng > 0) return 0;
      this.addTotalEng(this.eng);
      this.self_total_eng = this.total_eng;
      this.parents = [];
      this.overtone_count = 1;
      this.max_oevrtone_ori_eng = 0;
      this.accept_eng = 0;
      this.left_index--;
      this.right_index++;
      this.calculateParent(highest_index);
      for (var i = 2; i < 50; ++i) {
        if (i != highest_index) {
          if (!this.calculateParent(i)) break;
        }
      }
      this.index = (this.left_index + this.right_index) / 2;
      return this.total_eng;
    };

    Top.prototype.getAvgTotalEng = function() {
      return this.total_eng / this.overtone_count;
    }

    Top.prototype.getPure = function() {
      return this.total_eng / this.self_total_eng;
    };

    Top.prototype.getPureName = function() {
      var pure = this.getPure();
      var freq = data.indexToFreq(this.index);
      if (freq > 900 && pure > -8) { // This seems to be a custom logic rule
        return Locale.get('head_voice');
      }
      if (pure < 1.5) {
        return Locale.get('super_fake_voice');
      } else if (pure < 3) {
        return Locale.get('pure_fake_voice');
      } else if (pure < 4) {
        return Locale.get('fake_voice');
      } else if (pure < 5) {
        return Locale.get('half_fake_voice');
      } else if (pure < 6) {
        return Locale.get('mix_voice');
      } else if (pure < 20) {
        return Locale.get('modal_voice');
      } else {
        return Locale.get('pure_modal_voice');
      }
    };

    Top.prototype.addTotalEng = function(eng) {
      var sone = Math.pow(2, (eng - 40) / 10);
      this.total_eng += sone;
    };

    var top_model = {


      getValue: function() {
        data.tops = new Array(data.fft_size);

        if (!data.lock_spec) {
          var fft = data.use_mic ? data.mic_fft : data.fft;
          if (!fft.input) return; // Don't analyze if there's no input
          data.spectrum = fft.analyze('db');
          data.sample_rate = fft.input.context.sampleRate;
          var max_eng = 120;
          data.highest_index = 0;
          data.highest_eng = 0;
          data.ori_spectrum = new Array(data.spectrum.length);
          for (var i = 0; i < data.x_max; ++i) {
            var value = data.spectrum[i] + 140;
            data.ori_spectrum[i] = value;
            data.spectrum[i] = data.equal_loud.adjust(i, value);
            if (value > data.highest_eng) {
              data.highest_eng = value;
              data.highest_index = i;
            }
            max_eng = Math.max(max_eng, data.ori_spectrum[i]);
          }
          data.max_eng = max_eng;
          data.top_eng_range = (data.max_eng - data.min_eng) * data.top_eng_range_rate;
        }
      },

      guessPitch: function() {
        var spectrum = data.spectrum;
        if(!spectrum) return;
        data.pitch = null;
        data.max_top = null;
        // ====================== first loop
        {
          var last_up_index = 0;
          var low_eng = 1000;
          var last_top = null;

          for (var i = 0; i < spectrum.length; i++) {
            var eng = spectrum[i];

            if (i > 0) {
              if (eng > spectrum[i - 1]) {
                last_up_index = i;
              } else if (eng < spectrum[i - 1] && last_up_index > 0) {
                var top = null;
                if (!data.tops[last_up_index]) {
                  top = new Top(last_up_index);
                  if (!top.valid) {
                    top = null;
                  }
                }
                // check invalid top
                if (top) {
                  while (last_top) {
                    if (last_top.index * 2 <= top.index) break;

                    if (top.eng - low_eng >
                      data.fake_top_rate * (last_top.eng - low_eng)) {
                      // delete last top.
                      for (var k = last_top.left_index; k <= last_top.right_index; ++k) {
                        data.tops[k] = null;
                      }
                      low_eng = Math.min(low_eng, last_top.left_low_eng);
                      last_top = last_top.left_top;
                    } else if (last_top.eng - low_eng >
                      data.fake_top_rate * (top.eng - low_eng)) {
                      top = null;
                      break;
                    } else {
                      break;
                    }
                  }
                }


                if (top) {
                  top.left_low_eng = low_eng;
                  top.left_top = last_top;
                  for (var k = top.left_index; k <= top.right_index; ++k) {
                    data.tops[k] = top;
                  }
                  last_up_index = 0;
                  last_top = top;
                  low_eng = top.eng;
                }
                if (eng < low_eng) {
                  low_eng = eng;
                }

              }
            }

          }
        }

        // Guess pitch.
        var max_top = null; {
          data.highest_top = data.tops[data.highest_index];
          if (data.highest_top) {
            max_top = data.highest_top;
            var max_top_eng = data.highest_top.calculate(1);
            var highest_total_eng = data.highest_top.total_eng;
            var highest_overtone_count = data.highest_top.overtone_count;

            data.accept_eng = 0; //(data.highest_top.eng - data.min_eng) / 4 + data.min_eng;
            for (var i = 2; i < 10; ++i) {
              var top = data.getTop(data.highest_top.left_index / i, data.highest_top.right_index / i);
              if (!top) continue;
              if (top.index <= 6) break;
              var total_eng = top.calculate(i);
              if (top.overtone_count <= highest_overtone_count) continue;
              if (top.total_eng < highest_total_eng) continue;

              if (total_eng > max_top_eng) {
                max_top_eng = total_eng;
                max_top = top;
              }
            }
          }

          if (max_top) {
            var freq = max_top.index * data.sample_rate / 2 / data.fft_size;
            data.pitch = getPitch(freq);
            data.max_top = max_top;
          }
        }
      },
    };


    var spec = {
      x_min: 0,
      x_max: 100,
      y_min: 0,
      y_max: 100,
      x_scale: 2,

      onDraw: function() {

        noStroke();
        fill(data.spec_background_color);
        rect(this.x_min, this.y_min, this.width, this.height);
        
        var spectrum = data.ori_spectrum;
        if(!spectrum) return;

      let signalColor = color("#EF5350");
    stroke(signalColor);
    strokeWeight(1);

    // éå†æ‰€æœ‰é¢‘ç‡
    for (var i = 0; i < spectrum.length; i++) {
        // å°†é¢‘ç‡ç´¢å¼• i æ˜ å°„åˆ° Y åæ ‡
        let freq = map(i, 0, data.fft_size, 0, data.sample_rate / 2);
        let y = map(freq, 0, 5300, this.y_max, this.y_min);
        
        if (y < this.y_min) break;
        if (y > this.y_max) continue;

        // å°†è¯¥é¢‘ç‡çš„èƒ½é‡(eng)æ˜ å°„åˆ° X åæ ‡ï¼Œå³èƒ½é‡æ¡çš„é•¿åº¦
        let eng = spectrum[i] || 0;
        let x = map(eng, data.min_eng, data.max_eng - 20, this.x_min, this.x_max);
        x = constrain(x, this.x_min, this.x_max);

        // ä»å·¦åˆ°å³ç”»ä¸€æ¡ä»£è¡¨èƒ½é‡å¤§å°çš„æ°´å¹³çº¿
        line(this.x_min, y, x, y);
    }

    // 3. ç»˜åˆ¶ Debug ä¿¡æ¯ (å¦‚æœå¯ç”¨)
    if (data.debug) {
        fill('#f00'); // ä½¿ç”¨çº¢è‰²å¡«å……
        noStroke();
        for (var i = 0; i < data.tops.length; i+40) {
            let top = data.tops[i];
            if (!top) continue;

            // åŒæ ·ï¼Œé¢‘ç‡å†³å®šYï¼Œèƒ½é‡å†³å®šX
            let freq = top.index * (data.sample_rate / 2) / data.fft_size;
            let y = map(freq, 0, 5300, this.y_max, this.y_min);
            let eng = spectrum[i] || 0;
            let x = map(eng, data.min_eng, data.max_eng - 20, this.x_min, this.x_max);

            if (y < this.y_min) break;

            ellipse(x, y, 5, 5); // åœ¨èƒ½é‡æ¡çš„æœ«ç«¯ç”»ä¸€ä¸ªç‚¹
        }
    }

    // 4. ç»˜åˆ¶è¦†ç›–çš„æŒ‡ç¤ºçº¿ (å·²æ”¹ä¸ºæ°´å¹³)
    // è¾…åŠ©å‡½æ•°ï¼Œç”¨äºç”»æ°´å¹³çº¿å’Œæ ‡ç­¾
    const drawHorizontalLine = (freq, label, colorValue) => {
        let y = map(freq, 0, 5300, this.y_max, this.y_min);
        if (y > this.y_max || y < this.y_min) return;
        
        stroke(colorValue);
        strokeWeight(0.75);
        line(this.x_min, y, this.x_max, y);

        fill(colorValue);
        noStroke();
        textSize(10);
        textAlign(RIGHT, BOTTOM);
        text(label, this.x_max - 5, y - 2);
    };

    // ç»˜åˆ¶å›ºå®šçš„ Hz å‚è€ƒçº¿
    for (i = 1; i <= data.overtone_count; ++i) {
        let freq = data.line_value * i;
        drawHorizontalLine(freq, ' ', data.line_color);
    }

    if (data.mousemove_pitch) {
        drawHorizontalLine(data.mousemove_pitch.value, '', data.mouse_pitch_color);

        for (i = 2; i <= data.overtone_count; ++i) {
            let freq = data.mousemove_pitch.value * i;
            drawHorizontalLine(freq, '', data.overtone_color);
        }
    }

  if (data.pitch) { // æ£€æŸ¥ç¨‹åºæ˜¯å¦å·²æ£€æµ‹åˆ°éŸ³é«˜
      let centerX = this.x_min + this.width / 2; // è®¡ç®—æ­¤ç»„ä»¶çš„ä¸­å¿ƒXåæ ‡

      // ç»˜åˆ¶å…·ä½“çš„éŸ³å (ä¾‹å¦‚ "A6")
      fill(data.fill_color); // ä½¿ç”¨ä¸é¢‘è°±èƒ½é‡æ¡ä¸€è‡´çš„çº¢è‰²
      textSize(20); // ä½¿ç”¨æ›´å¤§çš„å­—å·
      textStyle(BOLD); // ä½¿ç”¨ç²—ä½“
      textAlign(CENTER, CENTER);
      text(data.pitch[data.pitch_name], centerX, this.y_max - 10); // æ”¾åœ¨æ ‡ç­¾ä¸‹æ–¹
      
      textStyle(NORMAL); // æ¢å¤ä¸ºæ­£å¸¸å­—ä½“ï¼Œé¿å…å½±å“å…¶ä»–åœ°æ–¹çš„æ–‡å­—
  }

      },


      drawPitch: function(pitch, color_name) {
        if (!pitch) return;
        this.drawPitchLine(pitch.value, pitch[data.pitch_name], color_name);
      },

      drawPitchLine: function(freq, pitch_text, color_name) {
        var x = this.freqToX(freq);

        if (x > this.x_max) return;
        data.setAlphaColor(color_name);
        line(x, this.y_min, x, this.y_max);

        data.setColor(color_name);
        text(pitch_text, x - 10, this.y_max + 22);
      },

      handleMouseMove: function() {
        if (this.mouseInRect()) {
          var freq = this.yToFreq(mouseY);
          data.mousemove_pitch = getPitch(freq);
        }
      },

      init: function(x1, x2, y1, y2) {
        this.x_min = x1;
        this.x_max = x2;
        this.y_min = y1;
        this.y_max = y2;
        this.y_scale *= data.fft_scale;
        this.width = this.x_max - this.x_min;
        this.height = this.y_max - this.y_min;
      },

      yToFreq: function(y) {
        y -= this.y_min;
        y = this.height - y;
        return map(y / this.y_scale, 0, data.fft_size, 0, data.sample_rate / 2);
      },
      freqToY: function(freq) {
        var y = map(freq, 0, data.sample_rate / 2, 0, data.fft_size);
        return this.y_max - y * this.y_scale;
      },

      engToY: function(eng) {
        return map(Math.max(data.min_eng, eng), data.min_eng, data.max_eng, this.y_max, this.y_min);
      },

      mouseInRect: function() {
        return mouseX > this.x_min && mouseX < this.x_max &&
          mouseY > this.y_min && mouseY < this.y_max
      },
    };


    function Buffer(width, height) {
      this.scale = data.image_scale;
      this.width = width * this.scale;
      this.height = height * this.scale;
      this.buffer = createImage(this.width, this.height);
      this.buffer.loadPixels();
    }

    Buffer.prototype.loadPixels = function() {
      this.buffer.loadPixels();
    }

    Buffer.prototype.updatePixels = function() {
      this.buffer.updatePixels();
    }

    Buffer.prototype.fillPoint = function(x, y, color) {
      var scale = this.scale;
      x *= scale;
      y *= scale;
      for (var i = 0; i < scale; ++i) {
        for (var j = 0; j < scale; j++) {
          this.buffer.set(x + i, y + j, color);
        }
      }
    }

    var vspec = {
      x_min: 0,
      x_max: 100,
      y_min: 0,
      y_max: 100,
      x_scale: 2,
      y_scale: 1,
      x_current: 0,
   
      fillData: function() {
        var spectrum = data.ori_spectrum;
        if (!data.lock_spec && spectrum) {
          let bgColor = color(data.spec_background_color);
        for (let y = 0; y < this.buffer.height; y++) {
            // ä½¿ç”¨ set() æ–¹æ³•ï¼Œå®‰å…¨åœ°å°†åƒç´ è®¾ç½®ä¸ºé»‘è‰²
            this.buffer.buffer.set(this.buffer.width - 2, y, bgColor);
        }
          for (var i = 0; i < spectrum.length; i++) {
            var ii = i * this.y_scale;
            if (ii > this.height) break;
            var eng = spectrum[i];
            var pitch_color = this.engToColor(eng);
            if (data.show_pitch_on_spec && data.pitch && i == Math.round(data.max_top.index)) {
              pitch_color = color(data.vspec_pitch_color);
            }
            for (var xx = 0; xx < this.x_scale; ++xx) {
              for (var yy = 0; yy < this.y_scale; yy++) {
                this.buffer.fillPoint(this.x_current + xx, this.height - ii - yy, pitch_color);
              }
            }

          }
          this.x_current += this.x_scale;
          if (this.x_current >= this.width) {
            this.x_current = 0;
          }
          this.buffer.updatePixels();
 
        }
      },

      onDraw: function() {
        this.fillData();

        stroke(data.border_color);
        fill(data.spec_background_color);
        rect(this.x_min, this.y_min, this.width, this.height);
        

        // è®¡ç®—å±å¹•æœ€å·¦ä¾§(x=0)åº”è¯¥æ˜¾ç¤ºç¼“å†²åŒº(buffer)çš„å“ªä¸ªåƒç´ ï¼Œ
        // æ‰èƒ½è®©ç¼“å†²åŒºçš„ this.x_current åƒç´ æ­£å¥½è½åœ¨å±å¹•çš„ fixed_offset_from_left ä½ç½®ä¸Šã€‚
        // To make buffer[this.x_current] appear at screen[fixed_offset_from_left],
        // the screen[0] must show buffer[start_x_in_buffer]. This is the calculation.
        var start_x_in_buffer = (-this.x_current + this.width * 2) % this.width;
        
        start_x_in_buffer = Math.floor(start_x_in_buffer);

        // -- ç»˜å›¾é€»è¾‘ä¿æŒä¸å˜ï¼Œå› ä¸ºå®ƒåªè´Ÿè´£å¿ å®åœ°å‘ˆç°è®¡ç®—å‡ºçš„ç”»é¢ --

        var first_chunk_width = this.width - start_x_in_buffer;
        image(this.buffer.buffer, start_x_in_buffer, 0, first_chunk_width, this.buffer.height,
          this.x_min, this.y_min, first_chunk_width, this.height);
        
        image(this.buffer.buffer, 0, 0, start_x_in_buffer, this.buffer.height,
          this.x_min + first_chunk_width, this.y_min, start_x_in_buffer, this.height);


        textSize(10);
        for (var i = 1; i <= data.overtone_count; ++i) {
          var freq = data.line_value * i;
          var pitch_text = freq + ' Hz';
          this.drawPitchLine(freq, pitch_text, 'line_color');
        }

        textSize(20);
        if (data.show_pitch_on_spec && data.pitch && data.max_eng) {
          stroke(data.pitch_color_alpha);
          fill(data.pitch_color_alpha);
          this.drawPitch(data.pitch);

        }


        textSize(18);
        var str = ' '
        if (data.lock_spec) {
          str += '                     ' + Locale.get('paused');
        }
        data.setAlphaColor('mouse_pitch_color');
        text(str, this.x_min + 5, this.y_min + 20);

        if (data.mousemove_pitch) {
          if (data.mix_overtone && keyIsPressed) {
            this.drawMixPitch(data.mousemove_pitch, false);
          } else {
            this.drawPitch(data.mousemove_pitch, 'mouse_pitch_color');
          }

          for (var i = 2; i <= data.overtone_count; ++i) {
            var freq = data.mousemove_pitch.value * i;
            var pitch_text = '';//Locale.get('overtone');
            if (data.mix_overtone && keyIsPressed) {
              this.drawMixPitchLine(freq, i % 2 == 0);
            } else {
              this.drawPitchLine(freq, pitch_text, 'overtone_color');
            }
          }
        }


      },

      drawPitch: function(pitch, color_name) {
        if (!pitch) return;
        this.drawPitchLine(pitch.value, pitch[data.pitch_name], color_name);
      },
      drawPitchLine: function(freq, pitch_text, color_name) {
        var y = this.freqToY(freq);
        if (y < this.y_min) return;

        data.setAlphaColor(color_name);
        line(this.x_min, y, this.x_max, y);
        data.setColor(color_name);
        text(pitch_text, this.x_max + 3, y + 7);
      },
      drawMixPitch: function(pitch, both) {
        if (!pitch) return;
        this.drawMixPitchLine(pitch.value, both);
      },
      drawMixPitchLine: function(freq, both) {
        var y = this.freqToY(freq);
        if (y < this.y_min) return;

        var x = this.x_max + 5;
        data.setAlphaColor('man_pitch_color');
        line(this.x_min, y, this.x_max, y);
        data.setColor('man_pitch_color');
        this.drawTri(x, y);
        x += 13;
        text(Locale.get('man'), x, y + 6);
        if (both) {
          y -= 1;
          x += 24;
          data.setAlphaColor('woman_pitch_color');
          line(this.x_min, y, this.x_max, y);
          data.setColor('woman_pitch_color');
          this.drawTri(x, y);
          x += 13;
          text(Locale.get('woman'), x, y + 6);
        }
      },
      drawTri: function(x, y) {
        var xx = 10;
        var yy = 7;
        triangle(x, y, x + xx, y + yy, x + xx, y - yy);
      },

      handleMouseMove: function() {
        if (this.mouseInRect()) {
          var freq = this.yToFreq(mouseY);
          data.mousemove_pitch = getPitch(freq);
        }
      },

      init: function(x1, x2, y1, y2) {
        this.x_min = x1;
        this.x_max = x2;
        this.y_min = y1;
        this.y_max = y2;
        this.y_scale *= data.fft_scale;
        this.width = this.x_max - this.x_min;
        this.height = this.y_max - this.y_min;
        data.x_max = this.height;
        data.y_max = this.height / this.y_scale;
        this.buffer = new Buffer(this.width, this.height);
        for (var x = 0; x < this.width; x++) {
          for (var y = 0; y < this.height; y++) {
            this.buffer.fillPoint(x, y, color('#FAF9F6'));
          }
        }
        var cache = new Array(101);
      var whiteColor = color('#FAF9F6'); 
      var redColor = data.fill_color; 

      for (var db = 0; db <= 100; db++) {
          var percent = db / 100;
          cache[db] = lerpColor(whiteColor, redColor, percent);
      }
      this.color_cache = cache;
      },

      yToFreq: function(y) {
        y -= this.y_min;
        y = this.height - y;
        return map(y / this.y_scale, 0, data.fft_size, 0, data.sample_rate / 2);
      },
      freqToY: function(freq) {
        var y = map(freq, 0, data.sample_rate / 2, 0, data.fft_size);
        return this.y_max - y * this.y_scale;
      },
      engToColor: function(eng) {
        var percent = map(eng, data.min_eng, data.max_eng - data.eng_delta, 0, 100);
        percent = Math.min(100, Math.round(percent));
        percent = Math.max(0, percent);
        return this.color_cache[percent];
      },
      mouseInRect: function() {
        return mouseX > this.x_min && mouseX < this.x_max &&
          mouseY > this.y_min && mouseY < this.y_max
      },
    }



var pitchLadder = {
    x_min: 0, x_max: 0, y_min: 0, y_max: 0, width: 0, height: 0,

    init: function(x1, x2, y1, y2) {
        this.x_min = x1;
        this.x_max = x2;
        this.y_min = y1;
        this.y_max = y2;
        this.width = x2 - x1;
        this.height = y2 - y1;
    },

    onDraw: function() {
        // ç»˜åˆ¶èƒŒæ™¯
        fill('#0d0d0d'); // ä½¿ç”¨ä¸€ä¸ªæ·±ç°è‰²èƒŒæ™¯
        noStroke();
        rect(this.x_min, this.y_min, this.width, this.height);

        // å®šä¹‰ä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œå°†é¢‘ç‡æ˜ å°„åˆ°æ­¤ç»„ä»¶çš„å‚ç›´ä½ç½®
        const freqToY = (freq) => {
            // æ³¨æ„ï¼šè¿™é‡Œçš„8000Hzæ˜¯ä¼°ç®—çš„æ˜¾ç¤ºä¸Šé™ï¼Œæ‚¨å¯ä»¥æŒ‰éœ€è°ƒæ•´
            return map(freq, 0, 5000, this.y_max, this.y_min);
        };
        
        // éå†æ‰€æœ‰å·²çŸ¥çš„éŸ³é«˜æ•°æ®
        for (let i = 0; i < PITCH_DATA.length; i++) {
            const pitch = PITCH_DATA[i];
            const y = freqToY(pitch.value);

            // åªæ˜¾ç¤º C notes çš„æ ‡ç­¾ä»¥é¿å…æ‹¥æŒ¤
            if (pitch.name.startsWith('C')) {
                stroke(150); // ç°è‰²çº¿
                strokeWeight(0.5);
                line(this.x_min, y, this.x_max, y);

                fill(200); // ç°è‰²æ–‡å­—
                noStroke();
                textSize(10);
                textAlign(CENTER, CENTER);
                text(pitch.name, this.x_min + this.width / 2, y - 10);
            }
        }
        
    }
};





    var piano = {

      onDraw: function() {
        if (!this.buffer) return;
        image(this.buffer.buffer, 0, 0, this.buffer.width, this.buffer.height, this.x_min, this.y_min, this.width, this.height);
        this.drawHalf();
      },

      initBuffer: function() {
        if (this.buffer) return;
        this.buffer = new Buffer(this.width, this.height);
        this.buffer.loadPixels();

        var white_color = color(data.piano_white_color);
        var black_color = color(data.piano_black_color);

        // Draw white keys
        for (var i = 0; i < this.size; i++) {
            var x_start = Math.round(i * this.white_width);
            var x_end = Math.round((i + 1) * this.white_width);
            for (var x = x_start; x < x_end; x++) {
                for (var y = 0; y < this.height; y++) {
                    this.buffer.fillPoint(x, y, white_color);
                }
            }
        }
        // Draw black keys
        for (var i = 0; i < this.size; i++) {
            if (this.blacks[i]) {
                var x_start = Math.round(this.getLeft(this.blacks[i]) - this.x_min);
                var x_end = x_start + Math.round(this.black_width);
                 for (var x = x_start; x < x_end; x++) {
                    for (var y = 0; y < this.black_height; y++) {
                        this.buffer.fillPoint(x, y, black_color);
                    }
                }
            }
        }
        // Draw key dividers
        for (var i = 1; i < this.size; ++i) {
          var x = Math.round(i * this.white_width);
          for (var y = 0; y < this.height; ++y) {
            this.buffer.fillPoint(x, y, black_color);
          }
        }
        this.buffer.updatePixels();
      },

      drawHalf: function(draw_white) {

        var range = getRange(data.range_name);
        if (range) {
          var left = this.getLeft(range.low);
          var right = this.getLeft(range.high) + this.getWidth(range.high);
          data.setColor('range_color');
          rect(left, this.y_min, right - left, this.height);
        }

        textSize(20);
        if (data.mousemove_pitch) {
          this.drawPitch(data.mousemove_pitch, 'mouse_pitch_piano_color');
        }

        if (data.pitch) {
          this.drawPitch(data.pitch, 'pitch_color');
        }

      },

      drawPitch: function(pitch, color_name) {
        if (!pitch) return;
        var x = this.getLeft(pitch);
        data.setAlphaColor(color_name);
        rect(x, this.y_min, this.getWidth(pitch), this.getHeight(pitch));

        data.setColor(color_name);
        text(pitch[data.pitch_name], x, this.y_max + 24);
      },

      init: function(x1, x2, y1, y2) {
        this.x_min = x1;
        this.x_max = x2;
        this.y_min = y1;
        this.y_max = y2;
        this.width = this.x_max - this.x_min;
        this.height = this.y_max - this.y_min;

        // *** MODIFICATION: Create an oscillator for piano sounds ***
        this.osc = new p5.Oscillator('triangle');
        this.osc.amp(0);
        this.osc.start();

        this.whites = [];
        this.blacks = [];
        var white_key_index = 0;
        for (var i = 0; i < PITCH_DATA.length; ++i) {
            var pitch = PITCH_DATA[i];
            if (pitch.is_white) {
                pitch.piano_index = white_key_index;
                this.whites[white_key_index] = pitch;
                white_key_index++;
            }
        }
        for (var i = 0; i < PITCH_DATA.length; ++i) {
            var pitch = PITCH_DATA[i];
            if (!pitch.is_white) {
                // Associate black key with the previous white key's index
                var prev_white_pitch = PITCH_DATA[i - 1];
                pitch.piano_index = prev_white_pitch.piano_index;
                this.blacks[prev_white_pitch.piano_index] = pitch;
            }
        }
        
        this.size = white_key_index;
        this.white_width = this.width / this.size;
        this.black_x_ratio = 0.6;
        this.black_width = this.white_width * this.black_x_ratio;
        this.black_height = this.height * 2 / 3;

        this.initBuffer();
      },

      getLeft: function(pitch) {
        var x = this.x_min + pitch.piano_index * this.white_width;
        if (!pitch.is_white) {
          // A black key sits on the crack between two white keys
          x += this.white_width - (this.black_width / 2);
        }
        return x;
      },

      getWidth: function(pitch) {
        if (pitch.is_white) return this.white_width;
        else return this.black_width;
      },
      getHeight: function(pitch) {
        if (pitch.is_white) return this.height;
        else return this.black_height;
      },

      pointToPitch: function(x, y) {
        var white_key_index = Math.floor(x / this.white_width);
        var x_in_key = (x / this.white_width) - white_key_index; // 0.0 to 1.0

        // Check for black key first, as they are on top
        if (y < this.black_height) {
            // Check for black key on the right side of the current white key
            if (this.blacks[white_key_index] && x_in_key > (1 - this.black_x_ratio / 2)) {
                return this.blacks[white_key_index];
            }
            // Check for black key on the left side of the current white key (belongs to previous index)
            if (white_key_index > 0 && this.blacks[white_key_index - 1] && x_in_key < (this.black_x_ratio / 2)) {
                return this.blacks[white_key_index - 1];
            }
        }
        
        // If not a black key, it's the white key underneath
        if(this.whites[white_key_index]) {
            return this.whites[white_key_index];
        }
        return null;
      },
      mouseToPitch: function() {
        if (!this.mouseInRect()) return null;
        return this.pointToPitch(mouseX - this.x_min, mouseY - this.y_min);
      },

      playPitch: function(pitch) {
        if (!pitch) return;
        
        // *** MODIFICATION: Use the p5.Oscillator instead of loading a sound file ***
        setupInput(); // Ensure audio context is running
        this.osc.freq(pitch.value);
        this.osc.fade(0.3, 0.05); // Fade in quickly
        
        // Fade out after a short duration
        setTimeout(() => {
            this.osc.fade(0, 0.4); 
        }, 150);
      },

      mouseInRect: function() {
        return mouseX > this.x_min && mouseX < this.x_max &&
          mouseY > this.y_min && mouseY < this.y_max;
      },
    };


    var data = {
      mic: null,
      audio: null,
      fft: null,
      spectrum: null,
      tops: null,

      input_pane: true,
      show_spec: true,
      show_vspec: true,
      show_piano: false,
      show_pitch_on_spec: false,
      use_mic: false,
      no_mic: false,
      debug: false,

      sample_rate: 44100,
      fft_size: 1024,
      max_db: 140,

      lock_spec: false,

      width: 800,
      padding_right: 50,
      x_max: 1000,
      avg_spec: 0,
      min_eng: 60,
      max_eng: 140,
      eng_delta: 20,
      image_scale: 1,
      fft_scale: 2,
      smooth: 0.01,
      fps: 30,

      overtone_count: 5,
      overtone_accept_count: 3,
      overtone_accept_percent: 0.99,
      mix_overtone: false,
      top_eng_range_rate: 0.03,
      fake_top_rate: 4,

      pitch_name: 'inter',
      range_name: 'man_high',

      color_alpha: 220,
      spec_background_color: '#FAF9F6',
      fill_color: '#FF0000',
      stroke_color: '#FF0000',
      spec_text_color: '#212121',

      vspec_pitch_color: '#F44336',
      vspec_color_cache: true,

      pitch_color: '#F44336',
      range_color: 'rgba(33, 150, 243, 0.2)',
      man_pitch_color: '#64B5F6',
      woman_pitch_color: '#E64A19',

      overtone_color: '#F57F17',
      mouse_pitch_color: '#F9A825',
      mouse_pitch_piano_color: '#F9A825',
      line_color: '#9E9D24',
      line_value: 4000,

      border_color: '#FAF9F6',

      piano_white_color: '#FFFFFF',
      piano_black_color: '#000000',

      getTop: function(left, right) {
        var max_eng = 0;
        var max_top = null;
        left = Math.floor(left);
        right = Math.ceil(right);
        for (var i = left; i <= right; ++i) {
          var top = this.tops[i];
          if (top && top.eng > max_eng) {
            max_eng = top.eng;
            max_top = top;
          }
        }
        return max_top;
      },
      indexToFreq: function(i) {
        return map(i, 0, data.fft_size, 0, data.sample_rate / 2);
      },
      setColor: function(color_name) {
        var c = this[color_name];
        stroke(c);
        fill(c);
      },
      setAlphaColor: function(color_name) {
        var c = this[color_name + '_alpha'];
        stroke(c);
        fill(c);
      },

      init: function() {
        var screen_width = window.innerWidth;
        if (screen_width < this.width) {
          this.width = screen_width - this.padding_right - 20; // Add some extra padding
          vspec.x_scale = 1;
          this.show_spec = false;
        }

        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          this.no_mic = true;
        }

        var is_safari = /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);

        if (!is_safari) {
          this.fft_size = 2048;
          this.fft_scale = 1;
        }

        var prmstr = window.location.search.substr(1);
        if (prmstr != null && prmstr !== "") {

          var params = {};
          var prmarr = prmstr.split("&");
          for (var i = 0; i < prmarr.length; i++) {
            var tmparr = prmarr[i].split("=");
            var name = tmparr[0];
            var value = tmparr[1];
            if (value == 'false') {
              value = false
            } else if (jQuery.isNumeric(value)) {
              value = Number(value);
            }
            if (name.localeCompare('backup_pitch') == 0) {
              value = getPitch(value);
            }
            this[name] = value;
          }
        }
        this.line_value /= this.fft_size / 1024 * this.fft_scale;

        // handle colors.
        for (var key in this) {
          if (key.endsWith('_color')) {
            var c_name = this[key];
            if (typeof c_name === 'string' && c_name.startsWith('#')) {
                var c = color(c_name);
                this[key] = c;
                this[key + '_alpha'] = color(red(c), green(c), blue(c), this.color_alpha);
            } else if (typeof c_name === 'string' && c_name.startsWith('rgba')) {
                 var c = color(c_name);
                 this[key] = c;
            }
          }
        }
      },
    };
    </script>

</body>
</html>
